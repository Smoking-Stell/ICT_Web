<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Лабораторная1 - Akulov_Aleksey_K33391</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">Akulov_Aleksey_K33391</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem active">
                                <a href="./" class="nav-link">Лабораторная1</a>
                            </li>
                            <li class="navitem">
                                <a href="../Lab2/" class="nav-link">Лабораторная2</a>
                            </li>
                            <li class="navitem">
                                <a href="../Lab3/" class="nav-link">Лабораторная3</a>
                            </li>
                            <li class="navitem">
                                <a href="../Lab4/" class="nav-link">Лабораторная4</a>
                            </li>
                            <li class="navitem">
                                <a href="../Practices/" class="nav-link">Practices</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" class="nav-link disabled">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../Lab2/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#no1" class="nav-link">Отчет по лабораторной работе №1</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#1" class="nav-link">Задание 1</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#2" class="nav-link">Задание 2</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#3" class="nav-link">Задание 3</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#4" class="nav-link">Задание 4</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#5" class="nav-link">Задание 5</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_26" class="nav-link">Вывод</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="no1">Отчет по лабораторной работе №1</h1>
<p>Выполнил: Акулов Алексей, K33391</p>
<h4 id="_1">Цель работы:</h4>
<p>Овладеть практическими навыками и умениями реализации web-серверов и использования сокетов.</p>
<h2 id="1">Задание 1</h2>
<h3 id="_2">Текст задания:</h3>
<p>Реализовать клиентскую и серверную часть приложения. 
Клиент отсылает серверу сообщение «Hello, server». 
Сообщение должно отразиться на стороне сервера. 
Сервер в ответ отсылает клиенту сообщение «Hello, client». 
Сообщение должно отобразиться у клиента. Обязательно использовать библиотеку socket. 
Реализовать с помощью протокола UDP.</p>
<h4 id="_3">Реализация сервера:</h4>
<pre><code>import socket

IP = &quot;127.0.0.1&quot;
PORT = 44455


def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    server_socket.bind((IP, PORT))

    while True:
        data, addr = server_socket.recvfrom(1024)
        print(f&quot;Получено сообщение от {addr}: {data.decode()}&quot;)

        response = &quot;Hello, client&quot;
        server_socket.sendto(response.encode(), addr)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h4 id="_4">Реализация пользователя:</h4>
<pre><code>import socket

SERVER_IP = &quot;127.0.0.1&quot;
SERVER_PORT = 44455


def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

    message = &quot;Hello, server&quot;
    client_socket.sendto(message.encode(), (SERVER_IP, SERVER_PORT))

    data, addr = client_socket.recvfrom(1024)
    print(f&quot;Получено сообщение от {addr}: {data.decode()}&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h4 id="_5">Работа:</h4>
<p><img alt="Picture_1" src="../tests/img1.png" /></p>
<h2 id="2">Задание 2</h2>
<h3 id="_6">Текст задания:</h3>
<p>Реализовать клиентскую и серверную часть приложения. Клиент запрашивает у
сервера выполнение математической операции, параметры, которые вводятся с
клавиатуры. Сервер обрабатывает полученные данные и возвращает результат
клиенту. Вариант с учетом номера в журнале:</p>
<p><strong>Нахождение гипотенузы</strong></p>
<p>Обязательно использовать библиотеку socket
Реализовать с помощью протокола TCP</p>
<h4 id="_7">Решение</h4>
<p>Запускаем цикл, ожидая запроса от клиента, 
когда получаем запрос отправляем ему решение задачи</p>
<p>Пользователь вводит данные: 2 катета прямоугольного треугольника. 
Получает с сервера ответ.</p>
<h4 id="_8">Реализация сервера:</h4>
<pre><code>import socket
import math

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'


def solve_hypotenuse(a, b):
    return math.sqrt(a ** 2 + b ** 2)


def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((IP, PORT))
    server_socket.listen(10)

    while True:
        try:
            outer_socket, addr = server_socket.accept()
            received_string = outer_socket.recv(1024).decode(codage)

            a, b = map(float, received_string.split())
            result = solve_hypotenuse(a, b)
            outer_socket.send(str(result).encode(codage))
        except KeyboardInterrupt:
            server_socket.close()
            break


if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h4 id="_9">Реализация пользователя:</h4>
<pre><code>import socket

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'


def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((IP, PORT))

    inp_string = input(&quot;Enter the length of two legs: &quot;).encode(codage)
    client_socket.send(inp_string)

    result = client_socket.recv(1024).decode(codage)

    print(f&quot;Hypotenuse length: {result}&quot;)

    client_socket.close()


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h4 id="_10">Работа:</h4>
<p><img alt="Picture_2" src="../tests/img2.png" /></p>
<h2 id="3">Задание 3</h2>
<h4 id="_11">Текст задания:</h4>
<p>Реализовать серверную часть приложения. Клиент подключается к серверу. В ответ
клиент получает http-сообщение, содержащее html-страницу, которую сервер
подгружает из файла index.html.</p>
<h4 id="_12">Решение</h4>
<p>Создаем цикл для работы сервера и ожидания запроса пользователя. 
Когда получаем запрос, отправляем страницу и ответ статус ответа</p>
<h4 id="_13">Реализация сервера:</h4>
<pre><code>import socket
import math

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'


def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((IP, PORT))
    server_socket.listen(10)

    while True:
        try:
            outer_socket, addr = server_socket.accept()
            request = outer_socket.recv(1024).decode(codage)
            print(request)

            response_type = &quot;HTTP/1.0 200 OK\n&quot;
            headers = &quot;Content-Type: text/html\n\n&quot;
            with open(&quot;index.html&quot;, &quot;r&quot;) as f:
                body = f.read()

            response = response_type + headers + body
            outer_socket.send(response.encode(codage))
            outer_socket.close()
        except KeyboardInterrupt:
            server_socket.close()
            break


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h4 id="_14">Реализация пользователя:</h4>
<pre><code>import socket

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'


def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((IP, PORT))

    request = &quot;GET / HTTP/1.1\r\nHost: %s&quot; % IP
    client_socket.sendall(request.encode(codage))

    result = client_socket.recv(1024).decode(codage)

    print(result)

    client_socket.close()


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h4 id="_15">Сайт:</h4>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Pizza&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="_16">Работа:</h4>
<p><img alt="Picture_3" src="../tests/img3.png" /></p>
<h2 id="4">Задание 4</h2>
<h4 id="_17">Текст задания:</h4>
<p>Реализовать двухпользовательский или многопользовательский чат. 
Реализация многопользовательского часа позволяет получить максимальное количество 
баллов. Обязательно использовать библиотеку threading.</p>
<p>Для применения с TCP необходимо запускать клиентские подключения. 
И прием, и отправку сообщений всем юзерам на сервере в потоках. 
Не забудьте сохранять юзеров, чтобы потом отправлять им сообщения.</p>
<h4 id="_18">Решение:</h4>
<p>Основной момент - поддерживать всех текущих пользователей в глобальном массиве на сервере.
Необходимо создать два метода работы с клиентом: 
один отвечает за треда под одного из пользователей, а второй за отправку им всем сообщения</p>
<h4 id="_19">Реализация сервера:</h4>
<pre><code>import socket
import threading

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'

clients = []
client_names = {}


def elim_client(client_socket):
    client_socket.close()
    if client_socket in clients:
        clients.remove(client_socket)
    if client_socket in client_names:
        del client_names[client_socket]


def sharing_message(message, sender_socket):
    for client in clients:
        if client != sender_socket:
            try:
                client.send(message)
            except:
                elim_client(client)



def handle_client(client_socket):
    name = client_socket.recv(1024).decode(codage)
    client_names[client_socket] = name

    print(f&quot;{name} has joined the chat!&quot;)
    welcome_msg = f&quot;{name} has joined the chat!&quot;.encode(codage)
    sharing_message(welcome_msg, client_socket)

    while True:
        try:
            message = client_socket.recv(1024)
            formatted_message = f&quot;{name}: {message.decode(codage)}&quot;.encode(
                codage)
            sharing_message(formatted_message, client_socket)
        except:
            print(f&quot;{name} has left the chat!&quot;)
            leave_msg = f&quot;{name} has left the chat!&quot;.encode(codage)
            sharing_message(leave_msg, None)

            elim_client(client_socket)
            break


def main():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((IP, PORT))
    server_socket.listen(15)

    print(f&quot;Server listening on {IP}:{PORT}...&quot;)

    while True:
        client_socket, addr = server_socket.accept()
        clients.append(client_socket)
        client_thread = threading.Thread(target=handle_client,
                                         args=(client_socket,))
        client_thread.start()


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h4 id="_20">Реализация клиента:</h4>
<pre><code>import socket
import threading

IP = &quot;127.0.0.1&quot;
PORT = 44455
codage = 'utf-8'


def receive(client_socket):
    while True:
        message = client_socket.recv(1024).decode(codage)
        print(message)


def send(client_socket):
    while True:
        message = input()
        client_socket.send(message.encode(codage))


def main():
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((IP, PORT))

    username = input(&quot;Enter your username: &quot;)
    client_socket.send(username.encode(codage))

    receive_thread = threading.Thread(target=receive, args = (client_socket, ))
    send_thread = threading.Thread(target=send, args = (client_socket, ))

    receive_thread.start()
    send_thread.start()


if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h4 id="_21">Работа:</h4>
<p><img alt="Picture_4_1" src="../tests/img4_1.png" />
<img alt="Picture_4_2" src="../tests/img4_2.png" /></p>
<h2 id="5">Задание 5</h2>
<h4 id="_22">Текст задания:</h4>
<p>Необходимо написать простой web-сервер для обработки GET и POST http
запросов средствами Python и библиотеки socket.</p>
<p>Задание: сделать сервер, который может:
<br/>● Принять и записать информацию о дисциплине и оценке по дисциплине.
<br/>● Отдать информацию обо всех оценках по дисциплине в виде html-страницы.</p>
<h4 id="_23">Решение</h4>
<p>Используя шаблон реализуем сервер, сокращая send_response и parse_headers</p>
<h4 id="_24">Реализация сервера:</h4>
<pre><code>import socket
import sys



class MyHTTPServer:
    # Параметры сервера
    def __init__(self, ip, port, codage):
        self.ip = ip
        self.port = port
        self.grades = {}
        self.codage = codage

    def serve_forever(self):
        #1. Запуск сервера на сокете, обработка входящих соединений
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.bind((self.ip, self.port))
        server_socket.listen(10)
        while True:
            client_socket, addr = server_socket.accept()
            self.serve_client(client_socket)


    def serve_client(self, client_socket):
        # 2. Обработка клиентского подключения
        data = client_socket.recv(1024).decode(self.codage)
        try:
            request = self.parse_request(data)
            response = self.handle_request(request)
            if response:
                client_socket.send(response.encode('utf-8'))
        except Exception as e:
            error_msg = &quot;HTTP/1.1 400 Bad Request\n\n&quot;
            client_socket.send(error_msg.encode('utf-8'))
        finally:
            client_socket.close()

    def parse_request(self, data):
        # 3. функция для обработки заголовка http+запроса.
        # Python, сокет предоставляет возможность создать вокруг него некоторую обертку,
        # которая предоставляет file object интерфейс. Это дайте возможность построчно обработать запрос.
        # Заголовок всегда - первая строка. Первую строку нужно разбить на 3 элемента  (метод + url + версия протокола).
        # URL необходимо разбить на адрес и параметры (isu.ifmo.ru/pls/apex/f?p=2143 ,
        # где isu.ifmo.ru/pls/apex/f, а p=2143 - параметр p со значением 2143)
        lines = data.split('\r\n')
        headers = lines[0].split()
        print(f&quot;Headers : {headers}, {len(headers)}&quot;)

        if len(headers) != 3:
            raise Exception(&quot;Bad request line&quot;)

        body = lines[-1]
        print(body)
        grds = {}
        if &quot;:&quot; in body:
            grds = {grade.split(&quot;:&quot;)[0]: grade.split(&quot;:&quot;)[1]
                    for grade in body.split(&quot;;&quot;)}
        request = {&quot;method&quot;: headers[0], &quot;url&quot;: headers[1],
                   &quot;version&quot;: headers[2], &quot;grades&quot;: grds}

        return request


    def handle_request(self, request):
        # 5. Функция для обработки url в соответствии с нужным методом.
        # В случае данной работы, нужно будет создать набор условий,
        # который обрабатывает GET или POST запрос.
        # GET запрос должен возвращать данные.
        # POST запрос должен записывать данные на основе переданных параметров.
        if request[&quot;method&quot;] == &quot;POST&quot;:
            for subject, grade in request[&quot;grades&quot;].items():
                if subject not in self.grades:
                    self.grades[subject] = []
                self.grades[subject].extend(grade)
            #with open('index.html', 'r') as f:
            return f&quot;HTTP/1.1 200 OK\n\n&quot;
        elif request[&quot;method&quot;] == &quot;GET&quot;:
            response = f&quot;HTTP/1.1 200 OK\n\n&quot; \
                       + &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Grades&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;
            response += &quot;&lt;table border='1'&gt;&quot;
            response += &quot;&lt;tr&gt;&lt;th&gt;Subject&lt;/th&gt;&lt;th&gt;Grades&lt;/th&gt;&lt;/tr&gt;&quot;
            for subject, grades in self.grades.items():
                grades_str = &quot;, &quot;.join(map(str, grades))
                response += f&quot;&lt;tr&gt;&lt;td&gt;{subject}&lt;/td&gt;&lt;td&gt;{grades_str}&lt;/td&gt;&lt;/tr&gt;&quot;
            response += &quot;&lt;/table&gt;&quot;
            response += &quot;&lt;/body&gt;&lt;/html&gt;&quot;
            return response
        else:
            return &quot;HTTP/1.1 405 Something wrong with request\n\n&quot;

    #def send_response(self, *):
        # 6. Функция для отправки ответа. Необходимо записать в соединение status line вида HTTP/1.1 &lt;status_code&gt; &lt;reason&gt;.
        # Затем, построчно записать заголовки и пустую строку, обозначающую конец секции заголовков.

if __name__ == '__main__':
    IP = &quot;127.0.0.1&quot;
    PORT = 44455
    codage = 'utf-8'
    serv = MyHTTPServer(IP, PORT, codage)
    try:
        serv.serve_forever()
    except KeyboardInterrupt:
        pass



</code></pre>
<h4 id="post">POST запрос:</h4>
<pre><code>import socket


def test_post_request():
    IP = &quot;127.0.0.1&quot;
    PORT = 44455

    grades = {
        'Math2': 'С',
        'PE': 'C'
    }

    data = ';'.join([f&quot;{key}:{value}&quot; for key, value in grades.items()])

    headers = f&quot;POST / HTTP/1.1\r\nContent-Length: {len(data)}\r\n\r\n{data}&quot;

    test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    test_socket.connect((IP, PORT))
    test_socket.sendall(headers.encode())
    response = test_socket.recv(1024)

    print(&quot;Response:\n&quot;, response.decode())


if __name__ == &quot;__main__&quot;:
    test_post_request()

</code></pre>
<p>GET запрос:</p>
<pre><code>import socket

IP = &quot;127.0.0.1&quot;
PORT = 44455


def test_get_request():
    request = f&quot;GET / HTTP/1.1\r\nHost: {IP}\r\n\r\n&quot;

    test_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    test_socket.connect((IP, PORT))
    test_socket.sendall(request.encode())
    response = test_socket.recv(1024)

    print(&quot;Response:\n&quot;, response.decode())


if __name__ == &quot;__main__&quot;:
    test_get_request()

</code></pre>
<h4 id="_25">Работа</h4>
<p><img alt="Picture5_1" src="../tests/img5_1.png" /></p>
<p><img alt="Picture5_2" src="../tests/img5_2.png" /></p>
<h2 id="_26">Вывод</h2>
<p>При выполнении данной лабораторной работы я изучил работу с сокетами, TCP, UDP, HTTP сервера, научился работать с запросами.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
